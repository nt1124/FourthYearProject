typedef struct eccPoint
{
	mpz_t x;
	mpz_t y;

	unsigned char pointAtInf;
} eccPoint;


typedef struct eccParams
{
	mpz_t p;	// F_p modulo factor
	mpz_t a;	// coeff of x^1 in curve
	mpz_t b;	// constant coeff in curve
	mpz_t g;	// Generator of subgroup
	mpz_t n;	// Order of subgroup generated by g.
} eccParams;



struct eccPoint *initECC_Point()
{
	struct eccPoint *output = (struct eccPoint *) calloc(1, sizeof(struct eccPoint));

	mpz_init(output -> x);
	mpz_init(output -> y);

	output -> pointAtInf = 0;

	return output;
}



struct eccParams *initECC_Params()
{
	struct eccParams *output = (struct eccParams *) calloc(1, sizeof(struct eccParams));

	mpz_init(output -> p);
	mpz_init(output -> a);
	mpz_init(output -> b);
	mpz_init(output -> g);
	mpz_init(output -> n);

	return output;
}


// 2 means P_x == Q_x while P != Q. => infinity
// 1 means P == Q while P_y == 0.	=> infinity
// 0 otherwise	
int eccPointsEqCheck(struct eccPoint *P, struct eccPoint *Q)
{
	int toReturn = 0;

	if(0 == mpz_cmp(P -> x, Q -> x))
	{
		if(0 != mpz_cmp(P -> y, Q -> y))
		{
			toReturn = 2;
		}
		else if(0 == mpz_cmp_ui(P -> y, 0))
		{
			toReturn = 2;
		}
		else
		{
			toReturn = 1;
		}
	}


	return toReturn;
}



struct eccPoint *groupOp_Xs_unequal(struct eccPoint *P, struct eccPoint *Q, struct eccParams *params)
{
	mpz_t topHalf, lowerHalf, lowerHalf_inv, unsquared, squared, temp1, unmodded;
	struct eccPoint *output = initECC_Point();

	mpz_init(topHalf);
	mpz_init(lowerHalf);
	mpz_init(lowerHalf_inv);
	mpz_init(unsquared);
	mpz_init(squared);
	mpz_init(temp1);
	mpz_init(unmodded);

	// x3 = ((y2-y1)/(x2-x1))^2 - x1 - x2
	mpz_sub(topHalf, Q -> y, P -> y);
	mpz_sub(lowerHalf, Q -> x, P -> x);
	mpz_invert(lowerHalf_inv, lowerHalf, params -> p);

	mpz_mul(unsquared, topHalf, lowerHalf_inv);
	mpz_powm_ui(squared, unsquared, 2, params -> p);

	mpz_sub(temp1, squared, P -> x);
	mpz_sub(unmodded, temp1, Q -> x);
	mpz_mod(output -> x, unmodded, params -> p);


	// y3 = (x1-x3)*(y2-y1)/(x2-x1) - y1
	mpz_sub(topHalf, Q -> y, P -> y);
	mpz_sub(lowerHalf, Q -> x, P -> x);
	mpz_invert(lowerHalf_inv, lowerHalf, params -> p);
	mpz_mul(unsquared, topHalf, lowerHalf_inv);

	mpz_sub(topHalf, P -> x, output -> x);
	mpz_mul(temp1, topHalf, unsquared);

	mpz_sub(unmodded, temp1, P -> y);
	mpz_mod(output -> y, unmodded, params -> p);


	return output;
}


struct eccPoint *groupOp_Equal_NotZero(struct eccPoint *P, struct eccPoint *Q, struct eccParams *params)
{
	mpz_t topHalf, lowerHalf, lowerHalf_inv, threeX_1Sq, twoY_1, temp1, temp2, unmodded;
	struct eccPoint *output = initECC_Point();

	mpz_init(topHalf);
	mpz_init(lowerHalf);
	mpz_init(lowerHalf_inv);
	mpz_init(threeX_1Sq);
	mpz_init(twoY_1);
	mpz_init(temp1);
	mpz_init(temp2);
	mpz_init(unmodded);


	// x3 = ((3*x1^2 + a)/(2*y1))^2 - 2*x1
	mpz_powm_ui(temp1, P -> x, 2, params -> p);
	mpz_mul_ui(temp2, temp1, 3);
	mpz_add(topHalf, temp2, params -> a);


	// y3 = (x1-x3)*(3*x1^2 + a)/(2*y1) - y1




	return output;
}




struct eccPoint *groupOp(struct eccPoint *P, struct eccPoint *Q, struct eccParams *params)
{
	mpz_t topHalf, lowerHalf, lowerHalf_inv, unsquared, squared, temp1, unmodded;
	struct eccPoint *output;
	int eqCheck = eccPointsEqCheck(P, Q);


	mpz_init(topHalf);
	mpz_init(lowerHalf);
	mpz_init(lowerHalf_inv);
	mpz_init(unsquared);
	mpz_init(squared);
	mpz_init(temp1);
	mpz_init(unmodded);


	if(0 == eqCheck)
	{
		output = groupOp_Xs_unequal(P, Q, params);
	}
	else if(1 == eqCheck)
	{
		output = groupOp_Equal_NotZero(P, Q, params);
	}
	else
	{
		output = initECC_Point();
		output -> pointAtInf = 1;
	}
}